// Generated by continue
import {
  ContinueError,
  ContinueErrorReason,
  getRootCause,
} from "./errors";

describe("getRootCause", () => {
  it("should return the error itself if it has no cause", () => {
    const error = new Error("top level error");
    const result = getRootCause(error);
    expect(result).toBe(error);
  });

  it("should return the root cause when there is one level of nesting", () => {
    const rootCause = new Error("root cause");
    const error = new Error("top level error", { cause: rootCause });
    const result = getRootCause(error);
    expect(result).toBe(rootCause);
  });

  it("should return the deepest cause when there are multiple levels", () => {
    const deepestCause = new Error("deepest");
    const middleCause = new Error("middle", { cause: deepestCause });
    const topError = new Error("top", { cause: middleCause });
    const result = getRootCause(topError);
    expect(result).toBe(deepestCause);
  });

  it("should handle non-Error objects with cause property", () => {
    const rootCause = { message: "root cause object" };
    const error = { message: "top level", cause: rootCause };
    const result = getRootCause(error);
    expect(result).toBe(rootCause);
  });

  it("should handle undefined cause property", () => {
    const error = { message: "error", cause: undefined };
    const result = getRootCause(error);
    expect(result).toBe(error);
  });

  it("should handle null cause property", () => {
    const error = { message: "error", cause: null };
    const result = getRootCause(error);
    expect(result).toBe(error);
  });

  it("should handle string root cause", () => {
    const stringCause = "string error";
    const error = new Error("top", { cause: stringCause });
    const result = getRootCause(error);
    expect(result).toBe(stringCause);
  });
});

describe("ContinueError", () => {
  it("should create an error with reason and message", () => {
    const error = new ContinueError(
      ContinueErrorReason.FileNotFound,
      "File was not found"
    );
    expect(error.reason).toBe(ContinueErrorReason.FileNotFound);
    expect(error.message).toBe("File was not found");
    expect(error.name).toBe("ContinueError");
  });

  it("should create an error with reason only", () => {
    const error = new ContinueError(ContinueErrorReason.Unknown);
    expect(error.reason).toBe(ContinueErrorReason.Unknown);
    expect(error.message).toBe("");
    expect(error.name).toBe("ContinueError");
  });

  it("should be an instance of Error", () => {
    const error = new ContinueError(ContinueErrorReason.Unspecified);
    expect(error).toBeInstanceOf(Error);
  });

  it("should be catchable as Error", () => {
    let caughtError: Error | undefined;
    try {
      throw new ContinueError(
        ContinueErrorReason.FileWriteError,
        "Write failed"
      );
    } catch (e) {
      caughtError = e as Error;
    }
    expect(caughtError).toBeInstanceOf(ContinueError);
    expect((caughtError as ContinueError).reason).toBe(
      ContinueErrorReason.FileWriteError
    );
  });

  it("should include reason in stack trace context", () => {
    const error = new ContinueError(
      ContinueErrorReason.FindAndReplaceMissingOldString,
      "Missing old string"
    );
    expect(error.stack).toContain("ContinueError");
  });
});

describe("ContinueErrorReason enum", () => {
  it("should have unique values for all reasons", () => {
    const values = Object.values(ContinueErrorReason);
    const uniqueValues = new Set(values);
    expect(uniqueValues.size).toBe(values.length);
  });

  it("should have find and replace error reasons", () => {
    expect(ContinueErrorReason.FindAndReplaceIdenticalOldAndNewStrings).toBe(
      "find_and_replace_identical_old_and_new_strings"
    );
    expect(ContinueErrorReason.FindAndReplaceMissingOldString).toBe(
      "find_and_replace_missing_old_string"
    );
    expect(ContinueErrorReason.FindAndReplaceOldStringNotFound).toBe(
      "find_and_replace_old_string_not_found"
    );
  });

  it("should have file-related error reasons", () => {
    expect(ContinueErrorReason.FileNotFound).toBe("file_not_found");
    expect(ContinueErrorReason.FileAlreadyExists).toBe("file_already_exists");
    expect(ContinueErrorReason.FileWriteError).toBe("file_write_error");
    expect(ContinueErrorReason.FileTooLarge).toBe("file_too_large");
  });

  it("should have multi-edit error reasons", () => {
    expect(ContinueErrorReason.MultiEditEditsArrayRequired).toBe(
      "multi_edit_edits_array_required"
    );
    expect(ContinueErrorReason.MultiEditEditsArrayEmpty).toBe(
      "multi_edit_edits_array_empty"
    );
  });

  it("should have command execution error reasons", () => {
    expect(ContinueErrorReason.CommandExecutionFailed).toBe(
      "command_execution_failed"
    );
    expect(ContinueErrorReason.CommandNotAvailableInRemote).toBe(
      "command_not_available_in_remote"
    );
  });

  it("should have generic error reasons", () => {
    expect(ContinueErrorReason.Unknown).toBe("unknown");
    expect(ContinueErrorReason.Unspecified).toBe("unspecified");
  });
});
