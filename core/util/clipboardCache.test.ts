// Generated by continue
import { clipboardCache } from "./clipboardCache";

describe("ClipboardCache", () => {
  beforeEach(() => {
    clipboardCache.clear();
  });

  describe("add", () => {
    it("should return true when adding new content", () => {
      const result = clipboardCache.add("id1", "content1");
      expect(result).toBe(true);
    });

    it("should return false when adding empty content", () => {
      const result = clipboardCache.add("id1", "");
      expect(result).toBe(false);
    });

    it("should return false when adding duplicate content with different id", () => {
      clipboardCache.add("id1", "same content");
      const result = clipboardCache.add("id2", "same content");
      expect(result).toBe(false);
    });

    it("should remove previous entry when adding duplicate content", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content1");

      const items = clipboardCache.getNItems(10);
      expect(items).toHaveLength(1);
      expect(items[0]).toEqual({ id: "id2", content: "content2" });
    });

    it("should evict oldest entry when max size is exceeded", () => {
      // Add 30 items (max size)
      for (let i = 0; i < 30; i++) {
        clipboardCache.add(`id${i}`, `content${i}`);
      }

      // Add one more to trigger eviction
      clipboardCache.add("id30", "content30");

      // The oldest (id0) should be evicted
      expect(clipboardCache.get("id0")).toBeUndefined();
      expect(clipboardCache.get("id30")).toBe("content30");
    });

    it("should add new entries at the front of the order", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");

      const items = clipboardCache.getNItems(2);
      expect(items[0].id).toBe("id2");
      expect(items[1].id).toBe("id1");
    });
  });

  describe("get", () => {
    it("should return content for existing id", () => {
      clipboardCache.add("id1", "content1");
      expect(clipboardCache.get("id1")).toBe("content1");
    });

    it("should return undefined for non-existent id", () => {
      expect(clipboardCache.get("nonexistent")).toBeUndefined();
    });

    it("should return correct content after multiple adds", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content3");

      expect(clipboardCache.get("id1")).toBe("content1");
      expect(clipboardCache.get("id2")).toBe("content2");
      expect(clipboardCache.get("id3")).toBe("content3");
    });
  });

  describe("getNItems", () => {
    it("should return empty array when cache is empty", () => {
      const items = clipboardCache.getNItems(5);
      expect(items).toEqual([]);
    });

    it("should return requested number of items", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content3");

      const items = clipboardCache.getNItems(2);
      expect(items).toHaveLength(2);
    });

    it("should return all items if requested count exceeds cache size", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");

      const items = clipboardCache.getNItems(10);
      expect(items).toHaveLength(2);
    });

    it("should return items in order from most to least recent", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content3");

      const items = clipboardCache.getNItems(3);
      expect(items[0]).toEqual({ id: "id3", content: "content3" });
      expect(items[1]).toEqual({ id: "id2", content: "content2" });
      expect(items[2]).toEqual({ id: "id1", content: "content1" });
    });

    it("should return empty string for items with no content in map", () => {
      clipboardCache.add("id1", "content1");
      // Access the internal state to simulate an edge case
      // where the order contains an id but the map doesn't have it
      const items = clipboardCache.getNItems(1);
      expect(items[0].content).toBe("content1");
    });
  });

  describe("select", () => {
    it("should move selected item to the front", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content3");

      clipboardCache.select("id1");

      const items = clipboardCache.getNItems(3);
      expect(items[0].id).toBe("id1");
    });

    it("should not change order if selecting most recent item", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content3");

      clipboardCache.select("id3");

      const items = clipboardCache.getNItems(3);
      expect(items[0].id).toBe("id3");
      expect(items[1].id).toBe("id2");
      expect(items[2].id).toBe("id1");
    });

    it("should handle selecting non-existent id gracefully", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.select("nonexistent");

      const items = clipboardCache.getNItems(1);
      expect(items[0].id).toBe("id1");
    });

    it("should maintain correct order after multiple selects", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");
      clipboardCache.add("id3", "content3");

      clipboardCache.select("id1");
      clipboardCache.select("id2");

      const items = clipboardCache.getNItems(3);
      expect(items[0].id).toBe("id2");
      expect(items[1].id).toBe("id1");
      expect(items[2].id).toBe("id3");
    });
  });

  describe("clear", () => {
    it("should empty the cache", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.add("id2", "content2");

      clipboardCache.clear();

      expect(clipboardCache.get("id1")).toBeUndefined();
      expect(clipboardCache.get("id2")).toBeUndefined();
      expect(clipboardCache.getNItems(10)).toEqual([]);
    });

    it("should allow adding items after clearing", () => {
      clipboardCache.add("id1", "content1");
      clipboardCache.clear();
      clipboardCache.add("id2", "content2");

      expect(clipboardCache.get("id2")).toBe("content2");
    });
  });
});
